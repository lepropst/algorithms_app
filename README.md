# Section 1## Algorithm Analysis- 1.3.1 Exponent and Logarithm Review

- 1.3.2 Summation Review
- 1.4 Recurrence Relations and Estimation
- 1.4.1 Proof Techniques
- 1.5 Algorithm Analysis
- 1.5.1 Upper and Lower Bounds on Algorithm Complexity
- 1.5.2 Algorithm Complexity Usage
- 1.6 Analyzing Problems

 <details>
 <summary style="display: flex;">
    <h1>section 2</h1>
 </summary>

- 2.2 Arrays
- 2.2.1 Searching Arrays - Linear Search
- 2.2.2 Searching Arrays - Binary Search
- 2.2.3 Binary Search Exercise
- 2.2.4 Array Performance
- 2.3 Linked Lists
- 2.3.1 Using Linked Lists vs Arrays
- 2.3.2 Linked List Variations
- 2.4 Stacks and Queues
- 2.4.1 Stacks
- 2.4.2 Queues
- 2.4.3 Stack and Queue Performance
- 2.5 Recursion
- 2.5.1 Recursion Exercise
- Trees & Hash Tables
- 2.6 Trees
- 2.6.1 Tree Terminology
- 2.6.2 Binary Trees
- 2.6.3 Binary Search Trees
- 2.6.3.1 Binary Search Tree Node Insertion
- 2.6.3.2 Binary Search Tree Node Deletion
- 2.6.3.3 Binary Search Tree Interactive Animation
- 2.6.3.4 BST Insertion Exercise
- 2.6.3.5 BST Deletion Exercise
- 2.6.4 Binary Tree Traversal
- 2.6.5 Binary Tree Traversal Exercise
- 2.6.6 Binary Search Tree Performance
- 2.7 Hash Tables/Hash Maps
- 2.7.1 Collision Resolution
- 2.7.2 Hashing Access Performance
- 2.7.3 Hashing with Deletions
- 2.7.4 Hashing Exercises</details>

 <details>
 <summary style="display: flex;">
<h1>Section 3</h1>

</summary>

- 3.1 Overview and Outcomes for Topic 3
- 3.1 Overview and Outcomes for Topic 3
- 3.2 Unbalanced Binary Trees
- 3.3.1 Balance Factor of a Binary Tree
- 3.3.2 Balance Factor of a Node
- 3.3.3 Balance Factor Representation of a Tree
- 3.3.4 Balance Factor Exercises
- 3.3 Balance Measures
- 3.4 Ways to Balance Binary Trees
- AVL Trees
- 3.5 AVL Trees
- 3.5.1 AVL Tree Class
- 3.5.2 AVL Tree Algorithms
- 3.5.3 AVL Tree Balancing during Insertion
- 3.5.4 AVL Tree Rotations
- 3.5.4.1 Right Rotation for Balancing
- 3.5.4.2 Left Rotation for Balancing
- 3.5.4.3 Left-Right Rotation for Balancing
- 3.5.4.4 Right-Left Rotation for Balancing
- 3.5.5 AVL Tree Insertion Exercises
- 3.5.6 AVL Tree Node Deletion
- 3.5.6.1 AVL Tree Deletion Exercises
- 3.5.7 AVL Tree Balancing Summary
- 3.5.8 AVL Tree Interactive Animation
- 3.5.9 AVL Tree Performance
- 3.6 Practice Problems
- Topic 3 Assignments
</details>

<details>
<summary style="display: flex;">
<h1>Section 4</h1>

</summary>

- 4.2 Priority Queues
- 4.3 Priority Queue Implementation Options
- 4.4 Binary Heaps
- 4.4.1 Binary Heap Variations
- 4.4.2 Binary Heap Identification Exercises and Animation
- 4.4.3 Using a Binary Heap to represent a Priority Queue
- Heap Implementation
- 4.5 Inserting a Node Into a Binary Heap
- 4.5.1 Heap Node Insertion Example
- 4.5.2 More Heap Node Insertion Examples
- 4.5.3 Heap Node Insertion Animation
- 4.5.4 Heap Node Insertion Exercises
- 4.6 Removing a Node From a Binary Heap
- 4.6.1 Heap Node Removal Example
- 4.6.2 More Heap Node Removal Examples
- 4.6.3 Heap Node Removal Animation
- 4.6.4 Heap Node Removal Exercises
- 4.7 Heap Implementation as an Array
- 4.7.1 Heap Insertion Algorithm Using an Array Implementation
- 4.7.2 Example: Heap Insertion Using an Array Implementation
- 4.7.3 Array Implementation of Heap Exercises
- 4.8 More on Heaps and Priority Queues

</details>

<details>
<summary style="display: flex;">
<h1>Section 5</h1>

</summary>

- 5.2 Use of Sorting Algorithms
- 5.3 Review of Slower Sorting Algorithms
- 5.3.1 Selection Sort
- 5.3.1.1 Exercise: Selection Sort
- 5.3.1.2 Selection Sort Performance
- 5.3.2 Bubble Sort
- 5.3.2.1 Exercise: Bubble Sort
- 5.3.2.2 Bubble Sort Performance
- 5.3.3 Insertion Sort
- 5.3.3.1 Exercise: Insertion Sort
- 5.3.3.2 Insertion Sort Performance
- 5.3.4 Shell Sort
- 5.3.4.1 Exercise: Shell Sort
- 5.3.4.2 Shell Sort Performance
- Review of Faster Sorts
- 5.4 Review of Faster Sorting Algorithms
- 5.4.1 Merge Sort
- 5.4.1.1 Exercise: Merge Sort
- 5.4.1.2Merge Sort Performance
- 5.4.2 Quicksort
- 5.4.2.1 Quicksort Partitioning
- 5.4.2.2 Exercise: Quicksort
- 5.4.2.3 Quicksort Improvements and Performance
- 5.4.3 Sorting Issue: Stability
- 5.4.4 Comparison of Faster Sorting Algorithms
- 5.5 More Interactive Sorting Animations
- Heap Sort
- 5.6 Another O(n log n) sorting algorithm: Heapsort
- 5.7 In-place Heap Sort Algorithm
- 5.7.1 Step 1: Build the Heap
- 5.7.1.1 Code for Converting a Binary tree to a Heap
- 5.7.1.2 Exercise: Convert Unsorted List to a Heap
- 5.7.2 Step 2: Sort the Heap
- 5.7.2.1 Code for Sorting a Heap
- 5.7.2.2 Exercise: Sort a Heap
- 5.8 More on Heaps and Heapsort (Animation/OpenDSA)
- 5.9 HeapSort Performance and Comparison to Quicksort

</details>

<details>
<summary style="display: flex;">
<h1>Section 6</h1>

</summary>

- 6.2 How Fast Can We Sort?
- 6.3 The Count Sort
- 6.3.1 Count Sort Variation
- 6.3.2 Count Sort Performance
- 6.3.3 Exercise: Count Sort Variation
- 6.4 The Bin Sort
- 6.5 The Bucket Sort
- 6.5.1 Bucket Sort Examples
- 6.5.2 Bucket Sort Variation and Animation
- 6.5.3 Bucket Sort Exercise
- 6.5.4 Bucket Sort Performance
- 6.6 The Radix Sort
- 6.6.1 Radix Sort Examples and Animation
- 6.6.2 Exercise: Radix Sort
- 6.6.3 Exercise: Radix Sort (strings)
- 6.6.4 Radix Sort Performance and More on Radix Sort
- 6.7 Advantages and Disadvantages of Linear Sorts
- 6.8 Deciding what Sort to Use
</details>

<details>
<summary style="display: flex;">
<h1>Section 7</h1>

</summary>

- 7.2 The Greedy Approach
- 7.2.1 Simple Examples of using the Greedy Approach
- 7.3 The Knapsack Problem
- 7.3.1 The Fractional Knapsack Problem
- 7.3.2 Fractional Knapsack Exercise
- 7.4 The Task Scheduling Problem
- 7.4.1 Task Scheduling Algorithm
- 7.4.2 Task Scheduling Exercise
- 7.4.3 Task Scheduling Algorithm Analysis
- 7.5 The Text Compression Problem
- 7.5.1 Huffman Coding Algorithm
- 7.5.2 Huffman Coding Example
- 7.5.3 Huffman Coding Example 2
- 7.5.4 Huffman Coding Exercises
- 7.5.5 Huffman Coding Analysis and More
- 7.6 Practice Problems
</details>

<details>
<summary style="display: flex;">
<h1>Section 8</h1>

</summary>

- 8.2 Divide and Conquer Method

_Divide problem into subproblems that are easier to solve._

- 8.2.1 Divide and Conquer Algorithm Examples

[merge sort quick sort, maximum value in a set of n numbers](https://worldclass.regis.edu/d2l/le/content/321597/viewContent/4601245/View)

- 8.3 Analyzing Divide-and-Conquer Algorithms

For example, to solve a single problem of size N:

You need to solve each sub-problem:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;First need to solve two sub-problems each of size approximately N/2.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Then when you apply the recursion again, you wind up with four sub-problems each of size approximately N/4.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Etc.

And in addition to the time required to solve the sub-problems, you need to include:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the time to split the original problem into sub-problems<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the time required to combine the solutions to the sub-problems into a single solution for the original problem.<br/>

- 8.3.1 Recurrence Relations

[page](https://worldclass.regis.edu/d2l/le/content/321597/viewContent/4601247/View)

- 8.4 The Master Theorem
- 8.4.1 Using the Master Theorem to solve Recurrence Relations
- 8.5 Matrix Multiplication
- 8.5.1 Strassen's Matrix Multiplication
- 8.5.2 Strassen's Matrix Multiplication Exercise
- 8.6 The Maxima Set Problem
- 8.6.1 Maxima Set Problem Brute Force Solution
- 8.6.2 Maxima Set Problem Divide and Conquer Solution '

</details>

<details>
<summary style="display: flex;">
<h1>Section 9</h1>
</summary>

- 9.2 Introduction to
- 9.2.1 Implementation of Dynamic Programming
- 9.3 Identifying Dynamic Programming Problems
- 9.4 The Knapsack Problem revisited

Knapsack problem can be solved using DP via tabulation or memoiztion

- 9.4.2 0/1 Knapsack Problem Exercise

- 9.5 Longest Common Subsequence Problem

[relevant link](https://worldclass.regis.edu/d2l/le/content/321597/viewContent/4601273/View)

- 9.5.1 Algorithms for Finding the Longest Common Subsequence

- 9.5.2 Finding the Longest Common Subsequence Exercises
- 9.5.3 Further Improvements when Implementing the LCS solution
- 9.6 Weighted Job Scheduling Algorithm
- 9.6.1 Weighted Job Scheduling Example
- 9.6.2 Determining Jobs in the Solution
- 9.6.3 Weighted Job Scheduling Exercise
- 9.7 Maximum Subarray Sum Revisted
- 9.8 Summary of Algorithm Techniques
</details>

<details>
<summary style="display: flex;">
<h1>Section 10</h1>

</summary>
- 10.2 Graph Definitions
- 10.2.1 Undirected Graphs
- 10.2.2 Directed Graphs
- 10.2.3 Additional Graph Definitions
- 10.2.4 Path Definitions
- 10.2.5 Graph Exercises
- 10.2.6 Graph Relationship Models
- 10.3 Graph Representations
- 10.3.1 Simplest Adjacency Matrix Representation
- 10.3.2 Simple Adjacency List
- 10.3.3 Adjacency Matrix Representation for Weighted Graphs
- 10.3.4 Graph Representation Exercises
- 10.3.5 More on Graph Definitions and Representations
- Graph Traversals, Connectedness, & Topological Sort
- 10.4 Graph Traversal
- 10.4.1 Graph Traversal Implementation
- 10.4.2 Breadth-First Graph Traversal
- 10.4.3 Breadth-First Traversal Example 1 (undirected graph)
- 10.4.4 Breadth-First Traversal Example 2 (directed graph)
- 10.4.5 Depth-First Graph Traversal
- 10.4.6 Depth-First Traversal Example 1 (undirected graph)
- 10.4.7 Depth-First Traversal Example 2 (directed graph)
- 10.4.8 Graph Traversal Exercises
- 10.4.9 Which Graph Traversal to Use?
- 10.5 Graph Connectedness
- 10.5.1 Connectedness Algorithms
- 10.6 Topological Sort
- 10.6.1 Topological Sort Examples

</details>

<details>
<summary style="display: flex;">
<h1>Section 11</h1>
</summary>
- 11.2 Defining The Shortest Path Problem
- 11.3 The Floyd-Warshall Algorithm

- 11.3.3 Variation to the Floyd-Warshall Algorithm
- 11.3.4 Floyd-Warshall Algorithm Exercises
- Single-Source Shortest Paths

- 11.4 The single-source shortest path problem
- 11.5 Dijkstra’s Algorithm

- 11.6 Graphs with negative weights

- 11.7 The Bellman-Ford Algorithm

</details>

8: Fundamental Techniques (Divide-and-and-Conquer)

9: Fundamental Techniques (Dynamic Programming)

10: Graphs

11: Shortest Paths

# Todo

[ ] ALL SORTS
[ ] Graph DS
